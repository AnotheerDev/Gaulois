REQUETE SQL

Quand vous réalisez une requête faites en sorte pour chaque clause SQL de les écrire les 
unes en dessous des autres et en MAJUSCULES



Une requête SQL doit contenir au minimum les éléments suivants :

La clause SELECT : cette clause spécifie les colonnes que vous voulez sélectionner dans votre requête.
La clause FROM : cette clause spécifie la table à partir de laquelle vous voulez sélectionner les données.
La clause WHERE : cette clause spécifie les conditions que les données doivent respecter pour être sélectionnées.
La clause GROUP BY (optionnelle) : cette clause spécifie la façon dont les données doivent être regroupées.
La clause HAVING (optionnelle) : cette clause spécifie les conditions que les groupes doivent respecter pour être sélectionnés.
La clause ORDER BY (optionnelle) : cette clause spécifie l'ordre dans lequel les données doivent être triées.



SELECT nom_personnage, id_personnage
FROM personnage
WHERE id_lieu = 1
ORDER BY nom_personnage


1. Nom des lieux qui finissent par 'um'.

SELECT nom_lieu
FROM lieu
WHERE nom_lieu
LIKE '%um'



2. Nombre de personnages par lieu (trié par nombre de personnages décroissant).

SELECT lieu.nom_lieu, COUNT(personnage.id_personnage) AS Nombre_Personnages
-- Sélectionne le nom du lieu et compte le nombre de personnages dans chaque lieu
FROM lieu
-- Sélectionne la table "lieu"
INNER JOIN personnage ON lieu.id_lieu = personnage.id_lieu
-- Effectue une jointure interne entre la table "lieu" et la table "personnage" en utilisant l'identifiant du lieu comme clé de jointure
GROUP BY lieu.id_lieu, lieu.nom_lieu
-- Groupe les résultats par l'identifiant du lieu et le nom du lieu
ORDER BY Nombre_Personnages DESC;
-- Trie les résultats par ordre décroissant du nombre de personnages



3. Nom des personnages + spécialité + adresse et lieu d'habitation, triés par lieu puis par nom de personnage.

SELECT personnage.nom_personnage, specialite.nom_specialite, personnage.adresse_personnage, lieu.nom_lieu
-- Sélectionne le nom du personnage, le nom de la spécialité, l'adresse du personnage et le nom du lieu
FROM personnage
-- Sélectionne la table "personnage"
INNER JOIN lieu ON personnage.id_lieu = lieu.id_lieu
-- Effectue une jointure interne entre la table "personnage" et la table "lieu" en utilisant l'identifiant du lieu comme clé de jointure
INNER JOIN specialite ON personnage.id_specialite = specialite.id_specialite
-- Effectue une jointure interne entre la table "personnage" et la table "specialite" en utilisant l'identifiant de la spécialité comme clé de jointure
ORDER BY lieu.id_lieu, personnage.nom_personnage;
-- Trie les résultats par ordre croissant de l'identifiant du lieu, puis par ordre croissant du nom du personnage




4. Nom des spécialités avec nombre de personnages par spécialité (trié par nombre de personnages décroissant)

SELECT specialite.nom_specialite, COUNT(personnage.id_specialite) AS Nombre_Personnages
-- Sélectionne le nom de la spécialité et compte le nombre de personnages pour chaque spécialité
FROM specialite
-- Sélectionne la table "specialite"
INNER JOIN personnage ON specialite.id_specialite = personnage.id_specialite
-- Effectue une jointure interne entre la table "specialite" et la table "personnage" en utilisant l'identifiant de la spécialité comme clé de jointure
GROUP BY specialite.id_specialite, specialite.nom_specialite
-- Groupe les résultats par l'identifiant de la spécialité et le nom de la spécialité
ORDER BY Nombre_Personnages DESC;
-- Trie les résultats par ordre décroissant du nombre de personnages pour chaque spécialité



5. Nom, date et lieu des batailles, classées de la plus récente à la plus ancienne (dates affichées au format jj/mm/aaaa).

SELECT nom_bataille, DATE_FORMAT(date_bataille, '%d/%m/%Y') AS date_formattee, nom_lieu
-- Sélectionne le nom de la bataille, la date formatée et le nom du lieu
FROM bataille
-- Spécifie la table "bataille" à partir de laquelle nous récupérons les données
INNER JOIN lieu ON bataille.id_lieu = lieu.id_lieu
-- Effectue une jointure interne (INNER JOIN) entre les tables "bataille" et "lieu" en utilisant la colonne "id_lieu" comme condition de correspondance entre les deux tables
ORDER BY date_bataille DESC;
-- Trie les résultats par ordre décroissant de la date de la bataille



6. Nom des potions + coût de réalisation de la potion (trié par coût décroissant)

SELECT potion.nom_potion, SUM(ingredient.cout_ingredient * composer.qte) AS cout_realisation
-- Sélectionne le nom de la potion et calcule le coût de réalisation total
FROM potion
-- Sélectionne depuis la table "potion"
INNER JOIN composer ON potion.id_potion = composer.id_potion
-- Effectue une jointure avec la table "composer" en utilisant l'identifiant de la potion comme clé de jointure
INNER JOIN ingredient ON composer.id_ingredient = ingredient.id_ingredient
-- Effectue une jointure avec la table "ingredient" en utilisant l'identifiant de l'ingrédient comme clé de jointure
GROUP BY potion.id_potion 
-- Groupe les résultats par l'identifiant de la potion
ORDER BY cout_realisation DESC; 
-- Trie les résultats par le coût de réalisation décroissant



7. Nom des ingrédients + coût + quantité de chaque ingrédient qui composent la potion 'Santé'.

SELECT ingredient.nom_ingredient, ingredient.cout_ingredient, composer.qte
-- Sélectionne les ingrédients, le cout des ingrédients et la quantité
FROM potion
-- Sélectionne depuis la table "potion"
INNER JOIN composer ON potion.id_potion = composer.id_potion
-- Effectue une jointure avec la table "composer" pour associer les ingrédients à la potion
INNER JOIN ingredient ON composer.id_ingredient = ingredient.id_ingredient
-- Effectue une jointure avec la table "ingredient" pour obtenir les détails de chaque ingrédient
WHERE potion.nom_potion = 'Santé';
-- Filtrage des résultats pour la potion 'Santé'



8. Nom du ou des personnages qui ont pris le plus de casques dans la bataille 'Bataille du village gaulois'.

SELECT personnage.nom_personnage, SUM(prendre_casque.qte) AS nombre_de_casques
-- Sélectionne le nom du personnage et la somme des casques pris
FROM personnage
INNER JOIN prendre_casque ON personnage.id_personnage = prendre_casque.id_personnage
INNER JOIN casque ON prendre_casque.id_casque = casque.id_casque
INNER JOIN bataille ON prendre_casque.id_bataille = bataille.id_bataille
-- Jointure des tables pour lier les informations
WHERE bataille.nom_bataille = 'Bataille du village gaulois'
-- Filtre pour obtenir seulement les informations de la "Bataille du village gaulois"
GROUP BY personnage.id_personnage
-- Regroupe les résultats par le ID du personnage
ORDER BY nombre_de_casques DESC
-- Trie les résultats par ordre décroissant du nombre de casques pris



9. Nom des personnages et leur quantité de potion bue (en les classant du plus grand buveur au plus petit).

SELECT personnage.nom_personnage, SUM(boire.dose_boire) AS quantite_bue
-- Sélectionne le nom du personnage la somme des quantitées bues
FROM personnage
INNER JOIN boire ON personnage.id_personnage = boire.id_personnage
-- Effectue une jointure avec la table "boire"
GROUP BY personnage.id_personnage, personnage.nom_personnage
-- Regroupe les résultats par le ID du personnage et nom du personnage
ORDER BY quantite_bue DESC;
-- Trie les résultats par ordre décroissant des quantitées bues



10. Nom de la bataille où le nombre de casques pris a été le plus important.

SELECT bataille.nom_bataille, SUM(prendre_casque.qte) AS nombre_de_casques
-- Sélectionne le nom de la bataille , la somme des casques 
FROM bataille
INNER JOIN prendre_casque ON bataille.id_bataille = prendre_casque.id_bataille
-- Effectue une jointure avec la table "prendre_casque"
GROUP BY bataille.id_bataille, bataille.nom_bataille
-- Regroupe les résultats par le ID de bataille et nom de bataille
ORDER BY nombre_de_casques DESC
-- Trie les résultats par ordre décroissant des casques pris lors de la bataille
LIMIT 1;
-- Garde que le premier resultat 



11. Combien existe-t-il de casques de chaque type et quel est leur coût total ? (classés par nombre décroissant).

SELECT type_casque.nom_type_casque, COUNT(casque.id_casque) AS nombre_de_casques, SUM(casque.cout_casque) AS cout_total
-- Sélectionne le nom du type de casque, le compte du nombre de casque et le cout total des casques du même type
FROM type_casque
INNER JOIN casque ON type_casque.id_type_casque = casque.id_type_casque
-- Effectue une jointure avec la table "casque"
GROUP BY type_casque.id_type_casque, type_casque.nom_type_casque
-- Regroupe les résultats par le ID du type de casque et le nom du type de casque
ORDER BY nombre_de_casques DESC;
-- Trie les résultats par ordre décroissant du nomùbre de casque par type



12. Nom des potions dont un des ingrédients est le poisson frais.

SELECT nom_potion
-- Sélectionne le nom de la ou des potion(s)
FROM potion
INNER JOIN composer ON potion.id_potion = composer.id_potion
-- Effectue une jointure avec la table composer
INNER JOIN ingredient ON composer.id_ingredient = ingredient.id_ingredient
-- Effectue une jointure avec la table ingredient
WHERE LOWER(ingredient.nom_ingredient)
LIKE 'poisson frais'
-- Filtre pour obtenir le nom de la potion qui contient poisson frais ATTENTION pour éviter la casse toujours mettre un LOWER() et un LIKE plutôt qu'un "=" quand on fait ce type de recherche on met en minuscule aussi pour éviter qu'une majuscule empêche de trouver l'élément en bdd
