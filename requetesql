REQUETE SQL

Quand vous réalisez une requête faites en sorte pour chaque clause SQL de les écrire les 
unes en dessous des autres et en MAJUSCULES



Une requête SQL doit contenir au minimum les éléments suivants :

La clause SELECT : cette clause spécifie les colonnes que vous voulez sélectionner dans votre requête.
La clause FROM : cette clause spécifie la table à partir de laquelle vous voulez sélectionner les données.
La clause WHERE : cette clause spécifie les conditions que les données doivent respecter pour être sélectionnées.
La clause GROUP BY (optionnelle) : cette clause spécifie la façon dont les données doivent être regroupées.
La clause HAVING (optionnelle) : cette clause spécifie les conditions que les groupes doivent respecter pour être sélectionnés.
La clause ORDER BY (optionnelle) : cette clause spécifie l'ordre dans lequel les données doivent être triées.



SELECT nom_personnage, id_personnage
FROM personnage
WHERE id_lieu = 1
ORDER BY nom_personnage


1. Nom des lieux qui finissent par 'um'.

SELECT nom_lieu
FROM lieu
WHERE nom_lieu
LIKE '%um'



2. Nombre de personnages par lieu (trié par nombre de personnages décroissant).

SELECT lieu.nom_lieu, COUNT(personnage.id_personnage) AS Nombre_Personnages
-- Sélectionne le nom du lieu et compte le nombre de personnages dans chaque lieu
FROM lieu
-- Sélectionne la table "lieu"
INNER JOIN personnage ON lieu.id_lieu = personnage.id_lieu
-- Effectue une jointure interne entre la table "lieu" et la table "personnage" en utilisant l'identifiant du lieu comme clé de jointure
GROUP BY lieu.id_lieu, lieu.nom_lieu
-- Groupe les résultats par l'identifiant du lieu et le nom du lieu
ORDER BY Nombre_Personnages DESC;
-- Trie les résultats par ordre décroissant du nombre de personnages



3. Nom des personnages + spécialité + adresse et lieu d'habitation, triés par lieu puis par nom de personnage.

SELECT personnage.nom_personnage, specialite.nom_specialite, personnage.adresse_personnage, lieu.nom_lieu
-- Sélectionne le nom du personnage, le nom de la spécialité, l'adresse du personnage et le nom du lieu
FROM personnage
-- Sélectionne la table "personnage"
INNER JOIN lieu ON personnage.id_lieu = lieu.id_lieu
-- Effectue une jointure interne entre la table "personnage" et la table "lieu" en utilisant l'identifiant du lieu comme clé de jointure
INNER JOIN specialite ON personnage.id_specialite = specialite.id_specialite
-- Effectue une jointure interne entre la table "personnage" et la table "specialite" en utilisant l'identifiant de la spécialité comme clé de jointure
ORDER BY lieu.id_lieu, personnage.nom_personnage;
-- Trie les résultats par ordre croissant de l'identifiant du lieu, puis par ordre croissant du nom du personnage




4. Nom des spécialités avec nombre de personnages par spécialité (trié par nombre de personnages décroissant)

SELECT specialite.nom_specialite, COUNT(personnage.id_specialite) AS Nombre_Personnages
-- Sélectionne le nom de la spécialité et compte le nombre de personnages pour chaque spécialité
FROM specialite
-- Sélectionne la table "specialite"
INNER JOIN personnage ON specialite.id_specialite = personnage.id_specialite
-- Effectue une jointure interne entre la table "specialite" et la table "personnage" en utilisant l'identifiant de la spécialité comme clé de jointure
GROUP BY specialite.id_specialite, specialite.nom_specialite
-- Groupe les résultats par l'identifiant de la spécialité et le nom de la spécialité
ORDER BY Nombre_Personnages DESC;
-- Trie les résultats par ordre décroissant du nombre de personnages pour chaque spécialité



5. Nom, date et lieu des batailles, classées de la plus récente à la plus ancienne (dates affichées au format jj/mm/aaaa).

SELECT nom_bataille, DATE_FORMAT(date_bataille, '%d/%m/%Y') AS date_formattee, nom_lieu
-- Sélectionne le nom de la bataille, la date formatée et le nom du lieu
FROM bataille
-- Spécifie la table "bataille" à partir de laquelle nous récupérons les données
INNER JOIN lieu ON bataille.id_lieu = lieu.id_lieu
-- Effectue une jointure interne (INNER JOIN) entre les tables "bataille" et "lieu" en utilisant la colonne "id_lieu" comme condition de correspondance entre les deux tables
ORDER BY date_bataille DESC;
-- Trie les résultats par ordre décroissant de la date de la bataille



6. Nom des potions + coût de réalisation de la potion (trié par coût décroissant)

SELECT potion.nom_potion, SUM(ingredient.cout_ingredient * composer.qte) AS cout_realisation
-- Sélectionne le nom de la potion et calcule le coût de réalisation total
FROM potion
-- Sélectionne depuis la table "potion"
INNER JOIN composer ON potion.id_potion = composer.id_potion
-- Effectue une jointure avec la table "composer" en utilisant l'identifiant de la potion comme clé de jointure
INNER JOIN ingredient ON composer.id_ingredient = ingredient.id_ingredient
-- Effectue une jointure avec la table "ingredient" en utilisant l'identifiant de l'ingrédient comme clé de jointure
GROUP BY potion.id_potion 
-- Groupe les résultats par l'identifiant de la potion
ORDER BY cout_realisation DESC; 
-- Trie les résultats par le coût de réalisation décroissant























